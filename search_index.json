[["index.html", "Close-kin mark-recapture: Theory and practice, Euring Technical Meeting — Montpellier, France Course Overview Workshop schedule Resources Post-workshop survey", " Close-kin mark-recapture: Theory and practice, Euring Technical Meeting — Montpellier, France Paul B. Conn April 21, 2023 Course Overview This is the website/book associated with the Close-kin Mark-recapture workshop to be held at the Euring Technical Meeting in Montpelier, France. Workshop schedule An approximate schedule for the workshop is as follows. Time Description 1:30–2:15 Close-kin mark-recapture: An overview 2:15–3:00 Genetic data and kinfinding lite 3:00–3:15 Break 3:15–4:15 Statistical inference for CKMR estimation 4:15–5:15 Designing CKMR experiments (including code demo) 5:15–5:30 Thought experiments / birds Resources All the materials for the workshop, including this “book” and all of the slides are located on github at https://github.com/pconn/euring-ckmr-2023 The “website” version of the course which serves up this book and the slides is available at https://pconn.github.io/euring-ckmr-2023/ These will remain publically available until something breaks! There is also additional material and examples that may be of interest at https://closekin.github.io/ and materials from a longer, full day workshop (cotaught w/ Eric Anderson) that includes more genetics detail and R/TMB code at https://eriqande.github.io/tws-ckmr-2022/ Post-workshop survey I’d really appreciate help in improving this workshop for future participants. After the workshop, please go to https://docs.google.com/forms/d/e/1FAIpQLSfV4LDzu9BJ24zuTCWaBo5c8vidF5CFUe-81Z59JMzBG-S-_g/viewform?usp=sf_link to fill one out. I’ll also email the link to participants. "],["preliminaries.html", "Preliminaries", " Preliminaries The course will start with 4 sets of slides, take a brief detour into a code demo for study design, and then finish up with a fifth set of slides.The following is the middle piece - the study design “code demo”! I’ll preface this with saying that I just plan on showing Rmarkdown in the workshop, as I’m not sure people really get much by cutting and pasting code snippets into R. There is also a bit of a toolchain to get this code working. However, if you’re interested in getting the code up and running you should follow the instructions at https://eriqande.github.io/tws-ckmr-2022/ I’ve followed Eric Anderson’s lead in using the Renv package to make sure R packages all work together (those used here date back to fall 2022). But you will also need to have RTools, etc. Please see Eric’s detailed instructions to try to get something working if you’re interested in running the code yourself. "],["design-of-ckmr-experiments-lab.html", "Design of CKMR Experiments lab Bearded seal simulation study", " Design of CKMR Experiments lab In this lab, we’ll use individual-based simulation to investigate impacts of assumption violations in CKMR models for bearded seals and examine anticipated precision. Bearded seal simulation study Let’s return to the biology and approximate sampling scheme for bearded seals (presented as slides in earlier in this workshop). Although bearded seal samples have already been gathered, we could look at a number of different features of data collection that could be relevant for future monitoring. Some ideas include: What type of precision can we expect on adult abundance? How does our current approach of treating age as known tend to affect estimates? Are we likely to be over- or under-estimating abundance or survival with this strategy? Overstating precision? If this is a large issue, we might want to institute procedures for better quantifying aging error (such as collecting two teeth, having them both read, and fitting aging error models to the data) What is the effect of employing fecundity-at-age schedules that overrepresent young animals? For instance, even though age 6 male bearded seals are sexually mature, what if they are not as reproductively successful as older seals? What seal covariates (e.g., age, sex) should be prioritized for genotyping if we’re to maximize precision in abundance estimates going forward? Our time in this workshop is limited, however, so let’s just address the first of these for this lab (what kind of standard error can we expect?). Setting up simulations: Population dynamics We’re going to use the R package CKMRpop to simulate some virtual bearded seal data, and fit an age structured CKMR model to these data. Given that it’s an age structured model, we’ll need to be careful that the simulation and estimation models are set up similarly - in particular we’ll want to make sure we get pre- and post-breeding census details correct. In fact, many published studies in the ecological literature have erred at this stage! (Kendall et al. (2019)). For bearded seals, pupping occurs from April-June on ice floes; harvests occur year round, but are primarily concentrated in the spring and summer. For this reason, we’ll use a “post-breeding census” where abundance is counted after reproduction has occurred. Pictorially, this looks like The part that people mess up most often is not incorporating survival into the fecundity term. We’ll include 40 ages (0-39) in our model, as the probability of a bearded seal surviving past that point is really small (I believe the oldest known age is in the 30s). Speaking of which, we’ll need to use some values of age-specific survival (\\(\\phi_a\\)) and female fecundity-at-age (\\(f_a\\)) to parameterize our simulation model. We’ll also need some information on male reproduction to determine who successfully mates or not. We’ll use data on male sexual maturity-at-age (call this \\(m_a\\)). We’ve developed a bearded seal survival schedule based on hierarchical meta-analysis of phocid natural mortality (Trukhanova et al. (2018)), and \\(f_a\\) and \\(m_a\\) schedules based on examination of gonadal inspections of harvested seals conducted by ADF&amp;G and reported in Russian literature. Here are some plots of these values. Let’s use these survival and fecundity values to parameterize a Leslie matrix model. Maturity = read.csv(&quot;./csv/Maturity.csv&quot;) Survival = read.csv(&quot;./csv/Survival_ests.csv&quot;) Reprod = read.csv(&quot;./csv/Reproduction_table.csv&quot;) Male_mat &lt;- rep(1,40) Fem_fec &lt;- rep(0.938,40) Male_mat[1:10]=c(0,Maturity$Bearded.male) Fem_fec[1:10]=c(0,Reprod$bearded) A = matrix(0,40,40) for(iage in 1:39){ A[iage+1,iage]=Survival[iage,&quot;bearded&quot;] #assume post-breeding census } #reproduction; nb: adults have to survive to next spring to reproduce # nb: Leslie matrices are &quot;female only&quot; and assume a 50/50 sex ratio at birth A[1,]=0.5*Fem_fec*Survival$bearded There’s a bit of a hiccup, however, since the population growth rate implied by this matrix (as determined by the dominant eigenvalue) is . Given that we’re going to need to perform simulation over 100 years (usually we have to go back two generations to get kinship relationships right), this would have the effect of inducing a 5400+0i percent increase in abundance over the simulation period!! This is clearly not desirable. It’s also an indication that there is probably something a bit off with our Leslie matrix, but it’s not clear where the bias might be. It could have to do with reproductively mature females not always producing a pup every year (\\(f_a\\) biased high), or with survival being overestimated. For the purposes of this simulation, though, we’ll lower survival by multiplying by a fixed constant until \\(\\lambda \\approx 1.0\\). Let’s write a quick function to figure out what this constant should be. leslie_obj &lt;- function(const,Survival,Fem_fec){ A = matrix(0,40,40) for(iage in 1:39){ A[iage+1,iage]=const*Survival[iage,&quot;bearded&quot;] #assume post-breeding census } A[1,]=0.5*Fem_fec*Survival$bearded*const lambda = eigen(A)$values[1] obj=(lambda-1.0)^2 obj } opt = nlminb(0.9,leslie_obj,Survival=Survival,Fem_fec=Fem_fec) print(opt$par,digits=4) ## [1] 0.9607 We’ve got it! Okay, we’ll multiply our current survival schedule by when we conduct our simulations - there will be some demographic stochasticity in any individual-based simulation, but given the large population size abundance should stay pretty much constant. Setting up simulations: CKMRpop Our next step will be to use the R package CKMRpop to simulate population dynamics. If you were using the ‘CKMRpop’ package on your own, you would need to install it first like this: remotes::install_github(&quot;eriqande/CKMRpop&quot;) However, it has already been installed for the euring-ckmr-2023 RStudio project by the ‘renv’ package, so if you are working in the euring-ckmr-2023 you do not have to do the above. However, after installing it, you will have to download the compiled spip binary which is the underlying simulation engine. That is done with the install_spip() function from the ‘CKMRpop’ as shown below: library(CKMRpop) library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union if(!spip_exists()) {install_spip(Dir = system.file(package = &quot;CKMRpop&quot;))} Now, let’s set up simulations with our bearded seal life history values. Note the quotation list structure is required by CKMRpop, and that the package is set up to work with a post-breeding census (good for us!). For definitions of the pars list, please use spip_help() or spip_help_full(). pars &lt;- list() pars$`max-age` &lt;- 40 #high survival so need to run for quite a while to kill everyone off pars$`fem-surv-probs` &lt;- pars$`male-surv-probs` &lt;- Survival$bearded*opt$par pars$`fem-prob-repro` &lt;- Fem_fec #probability of reproduction * pars$`repro-inhib` &lt;- 0 #this would allow us to specify e.g. that females couldn&#39;t have pups 2 years in a row (we don&#39;t have that issue!) pars$`male-prob-repro` &lt;- Male_mat pars$`fem-asrf` &lt;- rep(1,40) #if they reproduce, they will have at most 1 offspring pars$`male-asrp` &lt;- rep(1,40) #each reproductively mature male has same expected repro output pars$`offsp-dsn` &lt;- &quot;binary&quot; #override default neg. binomial dist. for litter size pars$`sex-ratio` &lt;- 0.5 Now we’ll set up some initial conditions and specify the length of the simulations. We’ll base the age structure of founders on stable age proportions computed using Leslie matrices, as calculated via the leslie_from_spip functionality in CKMRpop: pars$`number-of-years` &lt;- 120 # we need to specify initial cohort size instead of pop size; let&#39;s set it by assuming # a population size to be 400,000 and by using stable age proportions to figure out what # percentage will be pups N_init = 400000 Age_props = eigen(A)$vectors[,1]/sum(eigen(A)$vectors[,1]) cohort_size &lt;- as.numeric(round(N_init*Age_props[1])) # There&#39;s also some Leslie matrix functionality in spip we could use to set initial age strcutrue L &lt;- leslie_from_spip(pars, cohort_size) pars$`initial-males` &lt;- floor(L$stable_age_distro_fem) pars$`initial-females` &lt;- floor(L$stable_age_distro_male) pars$`cohort-size` &lt;- &quot;const 68737&quot; Note that when the cohort size argument is set to a constant, that the implied fecundity values in the Leslie matrix are rescaled so that the finite population growth rate, \\(\\lambda\\), is 1.0. This can be useful for simulation, but may make comparing fecundity values estimated by a CKMR model to those used to simulate the data difficult (although fecundity-at-age curves should be proportional). If this feature isn’t desired, CKMRpop can also be run with time-specific cohort sizes, or fishsim can be used for simulation. Next, we need to specify how the population is sampled. We’ll assume 20 years of sampling, which are preceded by 100 years of simulations time. This way we will likely capture the oldest possible grandparent-grandchild relationships (e.g., an individual who is age 35 at year 101 having a parent born in year 35 and a grandparent born in year 1). To be really careful we might have three generations time prior to sampling, but given that parents can’t reproduce until age 4 or 5, and that the chances of surviving to old age are very low, we should be fine. samp_start_year &lt;- 101 samp_stop_year &lt;- 120 pars$`discard-all` &lt;- 0 pars$`gtyp-ppn-fem-post` &lt;- paste( samp_start_year, &quot;-&quot;, samp_stop_year, &quot; &quot;, paste(rep(0.00025, pars$`max-age`), collapse = &quot; &quot;), sep = &quot;&quot; ) #basically we&#39;re saying that hunters aren&#39;t biased towards a particular age class, and that we&#39;re sampling 0.025% of the pop per year - about 100/year pars$`gtyp-ppn-male-post` &lt;- pars$`gtyp-ppn-fem-post` Okay, now that things are set up, we can run a CKMRpop simulation! This is super easy, although it takes a few minutes since we’re talking about simulating a populations size of 400,000 of 120 years and recording the geneaology along the way. I’m actually super impressed that this is so fast! I’ve put in an option for Rmarkdown to “cache” the results of this operation so that it doesn’t have to do it when this is compiled. So, just beware if you’re trying to run it on your own computer!! set.seed(2020) # inauspicious year as a seed for reproducibility of results spip_dir &lt;- run_spip(pars = pars) # run spip ## Running spip in directory /var/folders/24/8k48jl6d249_n_qfxwsl6xvm0000gn/T//Rtmp1ZTN3y/file180e57443f3d ## Done running spip. Output file size is 1130.219259 Mb ## Processing output file with awk ## Done processing output into spip_pedigree.tsv, spip_prekill_census.tsv, and spip_samples.tsv slurped &lt;- slurp_spip(spip_dir, 2) # read the spip output into R ## Rows: 1627 Columns: 3 ## ── Column specification ─────────────────────────────── ## Delimiter: &quot;\\t&quot; ## chr (2): X1, X2 ## lgl (1): X3 ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. ggplot_census_by_year_age_sex(slurped$census_postkill) The above plot shows the age and sex composition, as well as the total size of the population over time. For a design study the next thing we want to do is to start looking at sampled animals and number of kin pairs to make sure they line up with what we were hoping. nrow(slurped$samples) ## [1] 1627 crel &lt;- compile_related_pairs(slurped$samples) So, after 20 years of sampling (at an average of 81.35 samples per year), we end up with 1627 tissue samples. Assuming none are corrupted (a dubious assumption), they can be genetically analyzed and kin relationships can be determined. CKMRpop actually keeps track of a lot of relationships - more than are needed for CKMR analysis (at least in CKMR’s current state). Nevertheless, they can be useful because they can allow us to examine the performance of CKMR estimators when there are errors in kin determination (e.g., grandparent-grandchild or aunt-niece being mistaken for half-sibs). Here is a summary of true kin-pairs in our sample: relat_counts &lt;- count_and_plot_ancestry_matrices(crel) relat_counts$highly_summarised ## # A tibble: 5 × 3 ## dom_relat max_hit n ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 FC 1 54 ## 2 A 1 30 ## 3 Si 1 12 ## 4 GP 1 4 ## 5 PO 1 4 Note that there are 54 half-cousins (FC), 30 half-niblings (aunt-niece, uncle-niece, etc.), 12 half-siblings, 4 grandparent-grandchild, and 4 parent-offspring pairs. Note that the “max_hit” column indicates that number of shared ancestors at the level of the dominant relationship; so a “2” in this column would indicate a full sibling, full aunt-niece, etc. Since the maximum value if 1 here, this indicates they are all half-sibling, half-aunt-niece, etc. Which is good, since presence of full niblings/thiatics would confound HSP inference. There are some additional graphical tools in CKMRpop to examine pairwise relationships (see the plot_conn_comps() function, or investigate the “plots” objects in the relat_counts object), but we won’t do that here (free feel to do so yourself though!). What else may we deduce at this point? First, with only 4 POPs and 12 HSPs, we’re considerably below the “rule of thumb” of 50 kin pairs for reliable CKMR inference. These numbers may change slightly if we were to repeat the simulation, but the total number will be in the same ballpark. Second, we do get a substantial amount of GGPs, so we’ll need to accommodate these somehow, either by modeling or by restricting the time-of-death and age-ranges of HSP comparisons to make sure that GGPs are not included in HSP comparisons. We’re in the unique position of actually having conducted kin finding on \\(\\approx 1500\\) real bearded seal samples, so it is instructive to compare results of simulations to real data. When we analyzed real bearded seal data, we found 2 POPs, and depending on where we put the PLOD threshold, we arrived at 17-25 HSPs + GGPs. However, this number may have been inflated by a larger-than-expected number of PHSPs (arising, perhaps, from heterogeneity in male reproductive success). So simulations largely gave numbers very similar when we went and applied CKMR in practice, which is encouraging! Formatting data for estimation Now that we’ve simulated some data, we need to put them into a form that we can analyze. For our bearded seal paper, I programmed a log pseudo-likelihood in TMB (see bearded_nll.cpp in the TMB directory of this project), and we will use that for estimation here. This version does not include the capacity for modeling GGPs, so let’s ignore that added complication for now (the final analysis does, but calculations are quite complex). For both POPs and HSPs, we need to summarize sufficient statistics for the number of comparisons and number of matches. A typical way to do this is by grouping according to relevant covariates. For POPs this includes birth dates of the two animals being compared, as well as the death date of the older animal (because the older animal can’t be a parent if it dies before the younger animal is conceived (for a poential male parent) or before the younger animal is weaned (for a potential female parent). We’ll thus summarize POP comparisons and matches using three-dimensional arrays, which facilitate easy looping when calculating pseudolikelihood. We’ll also do maternal and paternal POPs separately. For HSPs, death dates are unneeded; all we need is the birth dates for prospective HSPs. Looking at male and female fecundity-at-age vectors, it looks like we should probably limit comparisons to animals that are born within \\(approx 6 years\\) of each other to preclude the possibility that an apparent HSP is actually a GGP. We’ll lose two HSPs in the process, but such is life! # here, &#39;bi&#39;, &#39;di&#39;, and &#39;bj&#39; index birth of the older animal, death of the older animal, and birth of the younger animal # as far as dimensions, there are 20 years of data, but birth dates can be earlier (up one generation time) n_comp_PPO_bidibj=n_comp_MPO_bidibj=n_match_PPO_bidibj=n_match_MPO_bidibj=array(0,dim=c(60,20,60)) # HSPs are indexed by bi, bj - the birth times of the older and younger animal; note that # the number of comparisons does not depend on the sex of the unobserved parent, but matches are sex-specific n_comp_HS_bibj = n_match_PHS_bibj= n_match_MHS_bibj= matrix(0,60,60) # POP matches PO_only &lt;- crel %&gt;% filter(dom_relat == &quot;PO&quot;) for(i in 1:nrow(PO_only)){ FIRST = (PO_only$born_year_1[i] &lt; PO_only$born_year_2[i]) # case 1: parent is animal 1 if(FIRST){ p_by = PO_only$born_year_1[i]-60 p_sex = (PO_only$sex_1[i]==&quot;M&quot;)+1 #1 for female, 2 for males p_dy = PO_only$samp_years_list_1[[i]]-100 o_by = PO_only$born_year_2[i] - 60 #year 81 in simulation = year 1 for CKMR inference } else{ p_by = PO_only$born_year_2[i]-60 p_sex = (PO_only$sex_2[i]==&quot;M&quot;)+1 #1 for female, 2 for males p_dy = PO_only$samp_years_list_2[[i]]-100 o_by = PO_only$born_year_1[i] - 60 #year 81 in simulation = year 1 for CKMR inference } if(p_sex==1)n_match_MPO_bidibj[p_by,p_dy,o_by]=n_match_MPO_bidibj[p_by,p_dy,o_by]+1 else n_match_PPO_bidibj[p_by,p_dy,o_by]=n_match_PPO_bidibj[p_by,p_dy,o_by]+1 } # HSP matches HS_only &lt;- crel %&gt;% filter(dom_relat == &quot;Si&quot;) for(i in 1:nrow(HS_only)){ FIRST = (HS_only$born_year_1[i] &lt; HS_only$born_year_2[i]) lt7 = (abs(HS_only$born_year_1[i] - HS_only$born_year_2[i])&lt;7) # case 1: parent is animal 1 if(lt7){ if(FIRST){ by1 = HS_only$born_year_1[i] - 60 by2 = HS_only$born_year_2[i] - 60 #year 81 in simulation = year 1 for CKMR inference } else{ by1 = HS_only$born_year_2[i] - 60 by2 = HS_only$born_year_1[i] - 60 #year 81 in simulation = year 1 for CKMR inference } #to determine sex of parent, we need to access ancestry vectors and pull off an &quot;M&quot; for male or &quot;F&quot; for female parent_ID = HS_only$ancestors_1[i][[1]][unlist(HS_only$primary_shared_ancestors[i])[1]] sex = substr(parent_ID,1,1) if(sex==&quot;F&quot;)n_match_MHS_bibj[by1,by2]=n_match_MHS_bibj[by1,by2]+1 else n_match_PHS_bibj[by1,by2]=n_match_PHS_bibj[by1,by2]+1 } } #Comparisons n_indiv = nrow(slurped$samples) for(i1 in 1:(n_indiv-1)){ for(i2 in (i1+1):n_indiv){ born_diff = slurped$samples$born_year[i1] - slurped$samples$born_year[i2] if(abs(born_diff)&lt;7){ if(born_diff&lt;0){ #first animal is older p_by = slurped$samples$born_year[i1]-60 p_dy = slurped$samples$samp_years_list[i1][[1]]-100 p_sex = (slurped$samples$sex[i1]==&quot;M&quot;)+1 #1 for female, 2 for males o_by = slurped$samples$born_year[i2] - 60 #year 81 in simulation = year 1 for CKMR } else{ if(born_diff&gt;0){ #note no comparisons for animals born in same year p_by = slurped$samples$born_year[i2]-60 p_dy = slurped$samples$samp_years_list[i2][[1]]-100 p_sex = (slurped$samples$sex[i2]==&quot;M&quot;)+1 #1 for female, 2 for males o_by = slurped$samples$born_year[i1] - 60 #year 81 in simulation = year 1 for CKMR } } if(p_sex==1)n_comp_MPO_bidibj[p_by,p_dy,o_by] = n_comp_MPO_bidibj[p_by,p_dy,o_by] + 1 else n_comp_PPO_bidibj[p_by,p_dy,o_by] = n_comp_PPO_bidibj[p_by,p_dy,o_by] + 1 n_comp_HS_bibj[p_by,o_by]=n_comp_HS_bibj[p_by,o_by]+1 } } } Fitting the CKMR model Okay, now we have our data formatted and it’s time to load up the jnll function from TMB, and pass data and initial parameter values to it to enable parameter estimation. Note that we’re going to pass fecundity schedules as known constants, and will handle survival by passing informative prior distributions into the estimation routine (it is a 3-parameter reduced-additive-Weibull model). Owing to low sample sizes, we’re also going to enforce a constraint of a constant population size. Here is some code to setup and run the model: Data=list(&quot;n_yrs&quot;=60,&quot;n_yrs_data&quot;=20,&quot;n_seals&quot;=nrow(slurped$samples),&quot;n_ages&quot;=40,&quot;Male_mat&quot;=Male_mat,&quot;Fem_fec&quot;=Fem_fec,&quot;A&quot;=A, &quot;n_match_PHS_bibj&quot;=n_match_PHS_bibj,&quot;n_match_MHS_bibj&quot;=n_match_MHS_bibj,&quot;n_comp_HS_bibj&quot;=n_comp_HS_bibj,&quot;n_match_MPO_bidibj&quot;=n_match_MPO_bidibj,&quot;n_comp_MPO_bidibj&quot;=n_comp_MPO_bidibj,&quot;n_match_PPO_bidibj&quot;=n_match_PPO_bidibj,&quot;n_comp_PPO_bidibj&quot;=n_comp_PPO_bidibj,mu_log_eta1=log(0.055),mu_log_eta2=log(2.8),mu_log_eta3=log(0.076),sd_log_eta1=0.07*abs(log(0.055)),sd_log_eta2=0.2*abs(log(2.8)),sd_log_eta3=abs(0.08*log(0.076)),lambda_expect=1.0) #SD log multipliers set to achieve approx CV of 0.2 on real scale Params = list(&quot;n0_log&quot;=log(20000),&quot;log_eta1&quot;=log(0.055),&quot;log_eta2&quot;=log(2.80),&quot;log_eta3&quot;=log(0.076)) #intial param values Map = list() #specify fixed parameter values #Random= c(&quot;log_eta1&quot;,&quot;log_eta2&quot;,&quot;log_eta3&quot;) Random=NULL library(TMB) getwd() ## [1] &quot;/Users/runner/work/euring-ckmr-2023/euring-ckmr-2023&quot; TmbFile = &quot;./TMB/bearded_nll.cpp&quot; compile(TmbFile ) ## [1] 0 TmbExec=&quot;./TMB/bearded_nll&quot; dyn.load(dynlib(TmbExec)) Obj &lt;- MakeADFun(data=Data, parameters=Params, random=Random, map=Map, hessian=FALSE, DLL=&quot;bearded_nll&quot;) Obj$fn( Obj$par ) ## [1] 2176425 Report = Obj$report() init_report = Report #Minimize negative log likelihood and time it Start_time = Sys.time() Opt = nlminb(start=Params, objective=Obj$fn, gradient=Obj$gr) ## outer mgc: 20936170 ## outer mgc: 8511535 ## outer mgc: 1708844 ## outer mgc: 1296351 ## outer mgc: 846387 ## outer mgc: 38796 ## outer mgc: 17648 ## outer mgc: 354.1 ## outer mgc: 2343 ## outer mgc: 180.7 ## outer mgc: 1431 ## outer mgc: 2875 ## outer mgc: 1552 ## outer mgc: 1150 ## outer mgc: 45.01 ## outer mgc: 180.9 ## outer mgc: 488.8 ## outer mgc: 123.3 ## outer mgc: 12.81 ## outer mgc: 4.869 ## outer mgc: 0.3811 ## outer mgc: 3.208 ## outer mgc: 8.661 ## outer mgc: 5.924 ## outer mgc: 45.47 ## outer mgc: 7.402 ## outer mgc: 1.951 ## outer mgc: 3.413 ## outer mgc: 3.515 ## outer mgc: 2.067 ## outer mgc: 0.2946 ## outer mgc: 0.02022 End_time = Sys.time() Report=Obj$report() SD_report=sdreport(Obj) ## outer mgc: 0.02022 ## outer mgc: 0.06032 ## outer mgc: 0.0199 ## outer mgc: 63308 ## outer mgc: 63004 ## outer mgc: 1107 ## outer mgc: 1110 ## outer mgc: 50079 ## outer mgc: 50038 ## outer mgc: 1406518 N_est_TMB = SD_report$value[which(names(SD_report$value)==&quot;N&quot;)] #check for convergence Opt$message ## [1] &quot;relative convergence (4)&quot; Okay, so it looks like our model converged, so it’s time to check on results. It looks like we’re estimating abundance as 2.7104^{5} with a standard error of 7.256^{4} - so the CV is 0.2677. That’s not bad! But, remember we’ve employed a large number of assumptions (constant abundance, etc.) to get an estimate with such low sample sizes. Our estimate (270,000) is lower than true abundance (400,000) but if we constructed a confidence interval it would include the true value, so it’s not something to be worried about. If we wanted to quantify estimator performance in a more rigorous way, we’d want to conduct a large number of simulations and look at things like bias, confidence interval coverage, etc. How about survival? Recall that CKMR can inform estimation of adult survival, which is why we used a prior on the three parameter survival-at-age function. Presumably the prior specifies all the information on juvenile and subadult survival, but the HSP data provide additional information on adult survival. There’s actually another hidden piece of information, and that is the constraint that population size is constant (basically a \\(\\lambda=1.0\\) constraint). So when we compare the prior survival model to the posterior survival model we see quite a shift - but a lot of that has to do with \\(\\lambda=1.0\\). Plot_df = data.frame(&quot;Type&quot;=rep(c(&quot;Prior&quot;,&quot;CKMR&quot;),each=40), &quot;Value&quot;=c(Survival$bearded,Report$S_a), &quot;Age&quot;= rep(c(0:39),2)) library(ggplot2) ggplot(Plot_df)+geom_line(aes(x=Age,y=Value,colour=Type),size=1.1)+theme(text=element_text(size=16)) Thought experiment What else about the bearded seal example would make sense to examine using simulation?? References Kendall BE, Fujiwara M, Diaz-Lopez J et al. (2019) Persistent problems in the construction of matrix population models. Ecological modelling, 406, 33–43. Trukhanova IS, Conn PB, Boveng PL (2018) Taxonomy-based hierarchical analysis of natural mortality: Polar and subpolar phocid seals. Ecology and evolution, 8, 10530–10541. "],["references.html", "References", " References Kendall BE, Fujiwara M, Diaz-Lopez J et al. (2019) Persistent problems in the construction of matrix population models. Ecological modelling, 406, 33–43. Trukhanova IS, Conn PB, Boveng PL (2018) Taxonomy-based hierarchical analysis of natural mortality: Polar and subpolar phocid seals. Ecology and evolution, 8, 10530–10541. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
